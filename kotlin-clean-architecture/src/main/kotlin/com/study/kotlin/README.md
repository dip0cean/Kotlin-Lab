## 계층형 아키텍처의 문제는 무엇일까?

### 계층형 아키텍처란?

> 웹 - 서비스 - 영속성계층으로 이루어진 아키텍처

#### 장점

- 누구나 이해하기 쉽다.
- 빠르게 변화하는 요구사항에 대해 즉각적으로 대응이 가능하다.

#### 단점

- 나쁜 개발 습관을 들이기 좋다.
- 시간이 지날 수록 유지보수가 어려운 소프트웨어로 변모하는 허점을 노출한다.

---

### 데이터베이스 주도 설계를 유도하는 계층형 아키텍처

> 계층형 아키텍처는 비즈니스 로직이 영속성 계층에 많은 의존성을 가지게 되는데,
> 이로 인해 자연스럽게 데이터베이스에 의존하여 개발하게 되는데, 이는 행동(behavior)이 주가 되어
> 유스케이스나 도메인을 중점적으로 개발하는 것이 아니라 상태(state)를 기준으로
> 모델링 하게 된다.

#### 왜 데이터베이스 주도 설계를 `지양`해야 할까?

- 도메인의 행위(Behavior)가 아닌 상태(State)를 기준으로 모델링하게 된다.
- 도메인의 비즈니스 로직이 영속성 모델에 대해 깊이 의존하게 되어 강한 결합이 발생한다.
- 비즈니스 로직에 집중하는 것이 아닌, 영속성 모델을 처리하는 방식에 대해서도 개발해야 한다. (Eager / Lazy Loading, Transaction 등)
- 모든 계층이 영속성 계층에 의존하게 될 가능성이 커지며, 헬퍼나 유틸성 클래스들도 영속성 계층과 결합이 발생할 수 있다.
- 테스트를 하기가 어려워진다.
    - 간단히 필드를 조작하는 일이라도 도메인 로직을 웹 계층(Controller) 에 구현하게 된다. 이로 인해 계층 별 책임이 모호해지고, 핵심 로직이 계층을 벗어날 수 있다.
    - 웹 계층 테스트에서 도메인 계층뿐만 아니라 영속성 계층도 모킹(Mocking) 해야 하는 문제가 발생된다.
- 넓은 서비스 구현체를 개발하게 되면서 영속성 계층에 많은 의존성을 갖게되고, 이는 곧 많은 컴포넌트가 서비스에 의존하게 되는 문제를 야기한다.
- 동시 작업이 어려워진다.

---

### UseCase

> UseCase 의 역할은 Incoming Adapter 로부터 입력을 받고,
> 도메인 계층의 실질적인 비즈니스 규칙 검증을 담당한다.
> 입력 유효성 검사는 별도의 계층에서 처리하도록 해 UseCase 가 온전히 비즈니스 로직만 처리할 수 있도록 한다.
>
> UseCase 는 비즈니스 규칙을 충족하면 입력을 기반으로 모델의 상태를 변경한다.
> 이를 통해 PersistenceAdapter 를 통해 구현된 Port 로 모델의 상태를 저장할 수 있게 한다.
> UseCase 는 또 다른 Outgoing Adapter 를 호출할 수 있다.

#### 입력 유효성 검증

> 입력 유효성 검증은 입력 모델이 담당하도록 해 UseCase 가 온전히 비즈니스 로직 및 규칙을 검증할 수 있도록 한다.
> 입력 모델은 Application 계층에 존재하는데, 그 이유는 Application Core 바깥에서부터 유효치 않은 값을 받게 되고,
> 결국 모델의 상태를 해칠 수 있기 때문이다.
>
> 따라서 입력 모델의 입력 유효성 검증 절차는 모델의 상태가 유효하다는 것을 검증하고,
> 후에 잘못된 상태로 변경할 수 없다는 사실을 보장한다.

#### 비즈니스 규칙 검증

> 비즈니스 규칙 검증은 유스케이스 로직의 일부이다.
> 비즈니스 규칙을 검증하기 위해서는 도메인 모델의 **현재 상태**에 접근해야 한다.
> 때문에 비즈니스 규칙은 유스케이스 맥락 속에서 **의미적인(semantical)** 유효성을 검증하는 일이다.
> 이러한 비즈니스 규칙을 검증을 수행할 때 권장하는 구현 방법은 도메인 엔티티 안에서 수행하도록 하는 것이다.
> 비즈니스 규칙을 도메인 엔티티 내부에서 수행하도록 하면 비즈니스 로직 바로 옆에 규칙이 위치하기 때문에 추론하기가 수월하다.
> 만약 이같은 방법을 구현하기 어렵다면 유스케이스 코드 내부에서 비즈니스 규칙을 검사해도 된다.

#### Builder vs Constructor

> Builder 패턴 뒤에 생성자를 감추는 경우 입력 유효성 검사에서 놓치는 부분이 발생할 수 있다.
> 때문에 Builder 패턴보다는 입력 인자가 풍부한 생성자를 사용하는 것을 권장한다.
>
> (나의 견해)
> Kotlin 에서는 풍부한 생성자를 정의해도 Builder 패턴처럼 사용 할 수 있고, Null 을 허용하지 않는 이상
> 모든 프로퍼티는 final 이기 때문에 크게 문제될 것 같지는 않다..!

#### 유스케이스마다 다른 입력 모델을 사용

> 비슷한 필드를 가지는 입력 모델을 서로 다른 유스케이스에서 필요로 하는 경우,
> 유스케이스 별 입력 모델을 만들어서 사용하는 것을 권장한디.
> 만약 서로 다른 유스케이스에서 같은 입력 모델을 사용하는 경우 하나의 클래스에서 여러 책임을 쳐야 하며,
> 특정 필드가 특정 유스케이스에서 사용하지 않는 경우 어떻게 처리해야 할지 다른 사람에게 혼란을 줄 수 있기 때문에
> 좋은 코드가 될 수 없다.

#### 유스케이스마다 다른 출력 모델을 사용

> 유스케이스 간 같은 출력 모델을 공유하게 되는 경우 **유스케이스들 또한 강하게 결합된다.**
> 한 유스케이스에서 출력 모델에 새로운 필드가 필요해지면, 이 값과 관련 없는 다른 유스케이스에서도 이 필드를 처리해야 하는데,
> 이는 단일 책임 원칙에 어긋나기 때문에 다른 입력 모델을 사용하는 것과 같이 출력 모델 또한 각기 다른 모델을 구현하여 사용해야 한다.

#### 풍부한 도메인 모델 vs 빈약한 도메인 모델

- 풍부한 도메인 모델

> 풍부한 도메인 모델은 애플리케이션의 코어에 있는 엔티티에서 가능한 한 많은 도메인 로직이 구현된다.
> 대부분의 도메인 로직이 도메인 모델 내부에 구현되어 유스케이스의 책임을 덜어낼 수 있다.

- 빈약한 도메인 모델

> 빈약한 도메인 모델은 Getter / Setter 를 제외한 어떠한 도메인 로직을 구현하고 있지 않다.
> 때문에 도메인 로직은 유스케이스에서 구현되어 있어 엔티티를 전달할 책임이 유스케이스 클래스에 있게 된다.

---

### Web Adapter

#### Web Adapter 의 책임

> 웹 어댑터는 URL, HTTP 메서드, Contents-Type 등 HTTP 프로토콜을 Java 객체로 역직렬화 하는 책임을 가진다.
> 또한 웹 어댑터의 입력 모델은 유스케이스의 입력 모델로 변환해 입력 유효성을 검증할 수 있어야 한다.
> 그렇기 때문에 이러한 입력 유효성 검사를 방해하는 요소는 모두 검증 에러로 처리하도록 해야 하며,
> 이를 통해 자연스럽게 변환된 입력 모델로 특정한 유스케이스를 호출하는 과정으로 연결된다.
>
> 또한, HTTP 관련된 로직은 웹 어댑터 계층을 넘어서 애플리케이션 계층으로 침투해서는 안된다.
> HTTP 관련 로직이 웹 어댑터 계층을 벗어나면 HTTP 를 다루지 않은 다른 유스케이스에서 동일한 도메인 로직을 수행할 수 있는
> 선택지를 잃게 된다.

#### Controller 나누기

> 컨트롤러는 너무 적은 것보다 많이 만들어 두는 것을 권장한다. (각 역할 별로 분류할 수 있도록 한다.)
> 만약 엔티티 별로 컨트롤러를 만들고, 엔티티 별 컨트롤러 내에서 다양한 로직을 처리하도록 코드를 작성한다면
> 코드의 양이 기하급수적으로 늘어나 추후 유지보수를 어렵게 만들며, 테스트 코드를 작성한다고 하더라도 해당 컨트롤러의 테스트 코드의 양도 많아져 복잡해질 수 있다.
> 또한, 모든 연산을 단일 컨트롤러에 넣는 경우 데이터 구조의 재활용을 촉진하게 되어 각 계층 별 역할을 침투하거나
> 각 역할 별로 필요한 데이터를 재활용하다보니 이를 구분 짓는 과정이 코드를 복잡하게 만든다.
> 때문에 컨트롤러는 **각 역할 별로 나누어** 관리하는 것을 권장한다.
>
> 작은 클래스들은 더 파악하기 쉽고, 테스트하기에도 수월하며, 동시에 여러 사람이 함께 작업이 가능하다는 장점이 있다.

---

### Persistence Adapter

#### 의존성 역전

> 헥사고날 아키텍처에서 `Persistence Adapter` 는 **주도되는** 혹은 **아웃고잉** 어댑터이다.
> 이러한 포트는 애플리케이션 계층에서 영속성 계층의 의존성을 제거하기 위해서 사용되는 간접 계층이다.
> 때문에 영속성 코드를 리팩토링하더라도 로직 코드를 변경하지 않아도 된다. (느슨한 결합)

#### Persistence Adapter 의 책임

> 영속성 어댑터는 포트 인터페이스를 통해 입력을 받으며 입력 모델은 인터페이스에서 지정한 도메인 엔티티나 특정 데이터베이스 연산 전용 객체를 받도록 한다.
> 즉, 영속성 어댑터의 입력 모델은 영속성 어댑터 내부가 아닌 외부의 애플리케이션 코어에 있기 때문에
> 영속성 어댑터 내부를 변경하더라도 애플리케이션 코어는 영향을 받지 않는다.

#### Port Interface 나누기

> 인터페이스 분리 원칙(Interface Segregation Principle, **ISP**) 을 이용해
> 클라이언트가 오로지 자신이 필요로 하는 메소드만 알면 되도록 특화된 인터페이스로 분리하도록 한다.
> 포트 인터페이스를 특정 역할만 충실하도록 설계하면 인터페이스를 의존하는 클래스를 테스트 할 때에도
> 수월하게 모킹할 수 있다.

#### Persistence Adapter 나누기

> **도메인 코드는 영속성 포트에 의해 정의된 명세를 어떤 클래스가 충족시키는지 관심을 가지면 안된다.**
> 또한 하나 이상의 클래스 생성을 금지하는 규칙이 존재하지 않기 때문에 영속성 연산이 필요한 도메인 클래스
> (DDD, 애그리거트) 하나당 하나의 Persistence Adapter 를 구현하는 방식을 선택할 수 있다.
> (즉, 도메인 역할에 따라 Port 를 구현하는 Persistence Adapter 를 분리해도 된다.)

#### Bounded Context ?

> Bounded Context 란 표현은 경계를 의미한다. 
> 각각의 도메인 Persistence Adapter 영역을 서로 접근하지 않는다는 의미를 가진다. 
> 만약 Bounded Context 를 넘어서 Persistence Adapter 에 접근해야 하는 경우 Incomming Port 를 통해서 접근할 수 있도록 해야 한다.

#### Transaction 의 경계는 어디에 위치해야 할까?

> Transaction 은 하나의 비즈니스 로직을 작업 하나로 바라보기 때문에 Persistence Adapter 가 이에 대한 책임을 지는 것은 옳지 않다. 
> 즉, 어떤 작업 중에 자신이 처리되는지 알 수 없기 때문에 Transaction 을 열고 닫음에 있어 결정을 관장 해서는 안된다.
> 때문에 Transaction 을 관장하는 계층은 Application Layer 의 UseCase 에서 이뤄져야 한다.
> (UseCase 는 하나의 비즈니스 로직, 하나의 작업 단위이기 때문이다.)
