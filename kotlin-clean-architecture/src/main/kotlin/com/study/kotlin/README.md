## 계층형 아키텍처의 문제는 무엇일까?

### 계층형 아키텍처란?

> 웹 - 서비스 - 영속성계층으로 이루어진 아키텍처

#### 장점

- 누구나 이해하기 쉽다.
- 빠르게 변화하는 요구사항에 대해 즉각적으로 대응이 가능하다.

#### 단점

- 나쁜 개발 습관을 들이기 좋다.
- 시간이 지날 수록 유지보수가 어려운 소프트웨어로 변모하는 허점을 노출한다.

---

### 데이터베이스 주도 설계를 유도하는 계층형 아키텍처

> 계층형 아키텍처는 비즈니스 로직이 영속성 계층에 많은 의존성을 가지게 되는데,
> 이로 인해 자연스럽게 데이터베이스에 의존하여 개발하게 되는데, 이는 행동(behavior)이 주가 되어
> 유스케이스나 도메인을 중점적으로 개발하는 것이 아니라 상태(state)를 기준으로
> 모델링 하게 된다.

#### 왜 데이터베이스 주도 설계를 `지양`해야 할까?

- 도메인의 행위(Behavior)가 아닌 상태(State)를 기준으로 모델링하게 된다.
- 도메인의 비즈니스 로직이 영속성 모델에 대해 깊이 의존하게 되어 강한 결합이 발생한다.
- 비즈니스 로직에 집중하는 것이 아닌, 영속성 모델을 처리하는 방식에 대해서도 개발해야 한다. (Eager / Lazy Loading, Transaction 등)
- 모든 계층이 영속성 계층에 의존하게 될 가능성이 커지며, 헬퍼나 유틸성 클래스들도 영속성 계층과 결합이 발생할 수 있다.
- 테스트를 하기가 어려워진다.
    - 간단히 필드를 조작하는 일이라도 도메인 로직을 웹 계층(Controller) 에 구현하게 된다. 이로 인해 계층 별 책임이 모호해지고, 핵심 로직이 계층을 벗어날 수 있다.
    - 웹 계층 테스트에서 도메인 계층뿐만 아니라 영속성 계층도 모킹(Mocking) 해야 하는 문제가 발생된다.
- 넓은 서비스 구현체를 개발하게 되면서 영속성 계층에 많은 의존성을 갖게되고, 이는 곧 많은 컴포넌트가 서비스에 의존하게 되는 문제를 야기한다.
- 동시 작업이 어려워진다.

---

### UseCase

> UseCase 의 역할은 Incoming Adapter 로부터 입력을 받고,
> 도메인 계층의 실질적인 비즈니스 규칙 검증을 담당한다.
> 입력 유효성 검사는 별도의 계층에서 처리하도록 해 UseCase 가 온전히 비즈니스 로직만 처리할 수 있도록 한다.
>
> UseCase 는 비즈니스 규칙을 충족하면 입력을 기반으로 모델의 상태를 변경한다.
> 이를 통해 PersistenceAdapter 를 통해 구현된 Port 로 모델의 상태를 저장할 수 있게 한다.
> UseCase 는 또 다른 Outgoing Adapter 를 호출할 수 있다.

#### 입력 유효성 검증

> 입력 유효성 검증은 입력 모델이 담당하도록 해 UseCase 가 온전히 비즈니스 로직 및 규칙을 검증할 수 있도록 한다.
> 입력 모델은 Application 계층에 존재하는데, 그 이유는 Application Core 바깥에서부터 유효치 않은 값을 받게 되고,
> 결국 모델의 상태를 해칠 수 있기 때문이다.
>
> 따라서 입력 모델의 입력 유효성 검증 절차는 모델의 상태가 유효하다는 것을 검증하고,
> 후에 잘못된 상태로 변경할 수 없다는 사실을 보장한다.

#### 비즈니스 규칙 검증

> 비즈니스 규칙 검증은 유스케이스 로직의 일부이다.
> 비즈니스 규칙을 검증하기 위해서는 도메인 모델의 **현재 상태**에 접근해야 한다.
> 때문에 비즈니스 규칙은 유스케이스 맥락 속에서 **의미적인(semantical)** 유효성을 검증하는 일이다.
> 이러한 비즈니스 규칙을 검증을 수행할 때 권장하는 구현 방법은 도메인 엔티티 안에서 수행하도록 하는 것이다.
> 비즈니스 규칙을 도메인 엔티티 내부에서 수행하도록 하면 비즈니스 로직 바로 옆에 규칙이 위치하기 때문에 추론하기가 수월하다.
> 만약 이같은 방법을 구현하기 어렵다면 유스케이스 코드 내부에서 비즈니스 규칙을 검사해도 된다.

#### Builder vs Constructor

> Builder 패턴 뒤에 생성자를 감추는 경우 입력 유효성 검사에서 놓치는 부분이 발생할 수 있다.
> 때문에 Builder 패턴보다는 입력 인자가 풍부한 생성자를 사용하는 것을 권장한다.
>
> (나의 견해)
> Kotlin 에서는 풍부한 생성자를 정의해도 Builder 패턴처럼 사용 할 수 있고, Null 을 허용하지 않는 이상
> 모든 프로퍼티는 final 이기 때문에 크게 문제될 것 같지는 않다..!

#### 유스케이스마다 다른 입력 모델을 사용

> 비슷한 필드를 가지는 입력 모델을 서로 다른 유스케이스에서 필요로 하는 경우,
> 유스케이스 별 입력 모델을 만들어서 사용하는 것을 권장한디.
> 만약 서로 다른 유스케이스에서 같은 입력 모델을 사용하는 경우 하나의 클래스에서 여러 책임을 쳐야 하며,
> 특정 필드가 특정 유스케이스에서 사용하지 않는 경우 어떻게 처리해야 할지 다른 사람에게 혼란을 줄 수 있기 때문에
> 좋은 코드가 될 수 없다.
